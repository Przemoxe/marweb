(function(){
  var __jpex_modules__ = [];
  // /src/$document.js
__jpex_modules__[1] = function(require, module, exports){
  module.exports = function ($window) {
    return $window.document;
};

};

// /src/$window.js
__jpex_modules__[2] = function(require, module, exports){
  module.exports = function () {
    return window;
};

};

// /node_modules/promise-polyfill/promise.js
__jpex_modules__[4] = function(require, module, exports){
  (function (root) {

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function noop() {}
  
  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function () {
      fn.apply(thisArg, arguments);
    };
  }

  function Promise(fn) {
    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    this._state = 0;
    this._handled = false;
    this._value = undefined;
    this._deferreds = [];

    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }
    if (self._state === 0) {
      self._deferreds.push(deferred);
      return;
    }
    self._handled = true;
    Promise._immediateFn(function () {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then;
        if (newValue instanceof Promise) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }
      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise._immediateFn(function() {
        if (!self._handled) {
          Promise._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }

  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) {
    var done = false;
    try {
      fn(function (value) {
        if (done) return;
        done = true;
        resolve(self, value);
      }, function (reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      });
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise.prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };

  Promise.prototype.then = function (onFulfilled, onRejected) {
    var prom = new (this.constructor)(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise.all = function (arr) {
    var args = Array.prototype.slice.call(arr);

    return new Promise(function (resolve, reject) {
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(val, function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.resolve = function (value) {
    if (value && typeof value === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function (resolve) {
      resolve(value);
    });
  };

  Promise.reject = function (value) {
    return new Promise(function (resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function (values) {
    return new Promise(function (resolve, reject) {
      for (var i = 0, len = values.length; i < len; i++) {
        values[i].then(resolve, reject);
      }
    });
  };

  // Use polyfill for setImmediate for performance gains
  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||
    function (fn) {
      setTimeoutFunc(fn, 0);
    };

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  /**
   * Set the immediate function to execute callbacks
   * @param fn {function} Function to execute
   * @deprecated
   */
  Promise._setImmediateFn = function _setImmediateFn(fn) {
    Promise._immediateFn = fn;
  };

  /**
   * Change the function to execute on unhandled rejection
   * @param {function} fn Function to execute on unhandled rejection
   * @deprecated
   */
  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
    Promise._unhandledRejectionFn = fn;
  };
  
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Promise;
  } else if (!root.Promise) {
    root.Promise = Promise;
  }

})(this);

};

// /src/$$promise.js
__jpex_modules__[3] = function(require, module, exports){
  module.exports = function () {
    if (typeof Promise !== 'undefined'){
        return Promise; // eslint-disable-line
    }
    return require(4);
};

};

// /node_modules/jpex-defaults/src/$copy.js
__jpex_modules__[6] = function(require, module, exports){
  module.exports = function ($typeof) {
    var exists;
    var alreadyCopied = function (obj, hash) {
        for (var x = 0, l = hash.length; x < l; x++){
            if (hash[x].from === obj){
                return obj;
            }
        }
    };
    var copier = function (from, to, recur, hash) {
        hash = hash || [];

        switch($typeof(from)){
        case 'string':
        case 'number':
        case 'boolean':
        case 'function':
        case 'null':
        case 'undefined':
            return from;

        case 'date':
            return new Date(from);

        case 'regexp':
            var flags = [];
            if (from.global){flags.push('g');}
            if (from.ignoreCase){flags.push('i');}
            return new RegExp(from.source, flags.join(''));

        case 'array':
            exists = alreadyCopied(from, hash);
            if (exists){
                return exists.to;
            }else{
                to = [];
                hash.push({from : from, to : to});
                from.forEach(function (item) {
                    to.push(recur ? copier(item, undefined, true, hash) : item);
                });
                return to;
            }

        case 'object':
            exists = alreadyCopied(from, hash);
            if (exists){
                return exists.to;
            }else{
                to = to || {};
                hash.push({from : from, to : to});
            }

            Object.keys(from).forEach(function (key) {
                to[key] = recur ? copier(from[key], to[key], recur, hash) : from[key];
            });
            return to;

        default:
            throw new Error('Unexpected type: ' + $typeof(from));
        }
    };

    var $copy = function (obj) {
        return $copy.shallow(obj);
    };
    $copy.shallow = function (obj) {
        return copier(obj);
    };
    $copy.deep = function (obj) {
        return copier(obj, null, true);
    };
    $copy.extend = function () {
        var args = Array.prototype.slice.call(arguments);
        var target = args.shift();
        args.forEach(function (arg) {
            copier(arg, target, true);
        });
        return target;
    };
    return $copy;
};

};

// /node_modules/jpex-defaults/src/$log.js
__jpex_modules__[7] = function(require, module, exports){
  module.exports = function () {
    /* eslint-disable no-console*/
    var $log = function () {
        return $log.log.apply(null, arguments);
    };
    $log.log = function () {
        return console.log.apply(null, arguments);
    };
    $log.info = function () {
        return console.info.apply(null, arguments);
    };
    $log.warn = function () {
        return console.warn.apply(null, arguments);
    };
    $log.error = function () {
        return console.error.apply(null, arguments);
    };
    return $log;
};

};

// /node_modules/jpex-defaults/src/$$promise.js
__jpex_modules__[8] = function(require, module, exports){
  module.exports = function () {
    return Promise; // eslint-disable-line
};

};

// /node_modules/jpex-defaults/src/$promise.js
__jpex_modules__[9] = function(require, module, exports){
  module.exports = function (Promise) {
    var $promise = function (fn) {
        return new Promise(fn);
    };
    $promise.all = Promise.all.bind(Promise);
    $promise.race = Promise.race.bind(Promise);
    $promise.reject = Promise.reject.bind(Promise);
    $promise.resolve = Promise.resolve.bind(Promise);

    return $promise;
};

};

// /node_modules/jpex-defaults/src/$timeout.js
__jpex_modules__[10] = function(require, module, exports){
  module.exports = function () {
    function timeout(cb, delay){
        return setTimeout(cb, delay);
    }
    timeout.clear = function(t){
        return clearTimeout(t);
    };
    return timeout;
};

};

// /node_modules/jpex-defaults/src/$interval.js
__jpex_modules__[11] = function(require, module, exports){
  module.exports = function(){
    function interval(cb, delay){
        return setInterval(cb, delay);
    }
    interval.clear = function (t) {
        return clearInterval(t);
    };
    return interval;
};

};

// /node_modules/jpex-defaults/src/$immediate.js
__jpex_modules__[12] = function(require, module, exports){
  module.exports = function ($timeout) {
    var native = (typeof setImmediate === 'function');
    function immediate(cb) {
        return native ? setImmediate(cb) : $timeout(cb, 0); // eslint-disable-line
    }
    immediate.clear = function (t) {
        return native ? clearImmediate(t) : $timeout.clear(t); // eslint-disable-line
    };
    return immediate;
};

};

// /node_modules/jpex-defaults/src/$typeof.js
__jpex_modules__[13] = function(require, module, exports){
  module.exports = function () {
    var standardTypes = ['number', 'boolean', 'string', 'array', 'function', 'date', 'regexp', 'null', 'undefined'];

    return function(obj, returnClassName){
        var t = Object.prototype.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
        return (!returnClassName && standardTypes.indexOf(t) < 0) ? 'object' : t;
    };
};

};

// /node_modules/jpex-defaults/src/index.js
__jpex_modules__[5] = function(require, module, exports){
  var $copy = require(6);
var $log = require(7);
var $$promise = require(8);
var $promise = require(9);
var $timeout = require(10);
var $interval = require(11);
var $immediate = require(12);
var $typeof = require(13);

exports.name = 'jpex-defaults';
exports.silent = true;

exports.install = function (options) {
    var Jpex = options.Jpex;

    Jpex.register.factory('$copy', ['$typeof'], $copy).lifecycle.application();

    Jpex.register.factory('$log', [], $log).lifecycle.application();

    Jpex.register.factory('$$promise', [], $$promise).lifecycle.application();

    Jpex.register.factory('$promise', ['$$promise'], $promise).lifecycle.application();

    Jpex.register.factory('$timeout', [], $timeout).lifecycle.application();

    Jpex.register.factory('$interval', [], $interval).lifecycle.application();

    Jpex.register.factory('$immediate', ['$timeout'], $immediate).lifecycle.application();

    Jpex.register.factory('$typeof', [], $typeof).lifecycle.application();
};

if (typeof window !== 'undefined' && window.Jpex && typeof window.Jpex.use === 'function'){
    window.Jpex.use(exports);
}

};

// /src/index.js
__jpex_modules__[0] = function(require, module, exports){
  var $document = require(1);
var $window = require(2);
var $$promise = require(3);

exports.name = 'jpex-web';
exports.install = function (options) {
    var Jpex = options.Jpex;

    if (!Jpex.$$factories.$promise){
        var defaults = require(5);
        Jpex.use(defaults);
    }

    Jpex.register.factory('$document', '$window', $document).lifecycle.application();

    Jpex.register.factory('$window', [], $window).lifecycle.application();

    Jpex.register.factory('$$promise', [], $$promise);
};

if (typeof window !== 'undefined' && window.Jpex && typeof window.Jpex.use === 'function'){
    window.Jpex.use(exports);
}

};

  var __jpex_require__ = function(target){
    if (__jpex_require__.cache[target]){
      return __jpex_require__.cache[target];
    }
    var module = { exports : {} };
    var fn = __jpex_modules__[target];
    if (!fn){
      throw new Error('Could not find module ' + target);
    }
    fn(__jpex_require__, module, module.exports);
    __jpex_require__.cache[target] = module.exports;

    return module.exports;
  };
  __jpex_require__.cache = [];

  if (typeof module !== 'undefined'){
    module.exports = __jpex_require__(0);
  }else if (typeof window !== 'undefined'){
    window['jpexWeb'] = __jpex_require__(0);
  }
}());
