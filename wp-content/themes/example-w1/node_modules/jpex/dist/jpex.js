(function(){
  var __jpex_modules__ = [];
  // /src/hasOwn.js
__jpex_modules__[2] = function(require, module, exports){
  var ObjectHasOwnProperty = Object.hasOwnProperty;
module.exports = function (obj, name) {
  return ObjectHasOwnProperty.call(obj, name);
};

};

// /src/constants.js
__jpex_modules__[3] = function(require, module, exports){
  exports.APPLICATION = 1;
exports.CLASS = 2;
exports.INSTANCE = 3;
exports.NONE = 4;

};

// /src/jpexError.js
__jpex_modules__[6] = function(require, module, exports){
  module.exports = function(mess){
  var e = new Error(mess);
  e.jpexInternalError = true;
  throw e;
};

};

// /src/resolver/factories.js
__jpex_modules__[5] = function(require, module, exports){
  var jpexError = require(6);
var constants = require(3);

exports.getFactory = function (Class, name, optional) {
  var factory;

  Class.$trigger('getFactory', {
    Class : Class,
    factoryName : name,
    set : function (value) {
      factory = value;
    }
  });

  if (!isValidFactory(factory)){
    factory = Class.$$resolved[name];

    if (!isValidFactory(factory)){
      factory = Class.$$factories[name];

      if (!isValidFactory(factory)){
        factory = Class.$$getFromNodeModules(name);

        if (!isValidFactory(factory)){
          if (optional){
            return;
          }else{
            jpexError(['Unable to find required dependency', name].join(' '));
          }
        }
      }
    }
  }

  return factory;
};

exports.decorate = function (Class, value, decorators) {
  if (!decorators || !decorators.length){
    return value;
  }
  for (var x = 0, l = decorators.length; x < l; x++){
    value = decorators[x].call(Class, value);
  }
  return value;
};

exports.cacheResult = function (Class, name, factory, value, namedParameters) {
  switch(factory.lifecycle){
  case constants.APPLICATION:
    factory.resolved = true;
    factory.value = value;
    break;
  case constants.CLASS:
    Class.$$resolved[name] = {
      resolved : true,
      value : value
    };
    break;
  case constants.NONE:
    break;
  case constants.INSTANCE:
  default:
    namedParameters[name] = value;
    break;
  }
};

function isValidFactory(factory) {
  return factory && ((factory.fn && typeof factory.fn === 'function') || factory.constant || factory.resolved);
}

};

// /src/resolver/index.js
__jpex_modules__[4] = function(require, module, exports){
  var hasOwn = require(2);
var factoryService = require(5);
var jpexError = require(6);

exports.extractParameters = function (fn) {
  var reg_comments = /\/\*(.*)\*\//g,
    chr_open = '(',
    chr_close = ')',
    chr_arrow = '=>',
    chr_delimeter = ',';

  var str = fn.toString();

  // Remove comments
  str = str.replace(reg_comments, '');

  // Find the start and end of the parameters
  var open = str.indexOf(chr_open);
  var close = str.indexOf(chr_close);
  var arrow = str.indexOf(chr_arrow);

  // Arrow functions may not contain brackets
  if (arrow > -1 && (arrow < open || open < 0)){
    str = str.substring(0, arrow).trim();
    return str ? [str] : [];
  }

  // Pull out the parameters and split into an array
  str = str.substring(open + 1, close);
  return str ? str.split(chr_delimeter).map(function (s) {
    return s.trim();
  }) : [];
};

exports.resolveDependencies = function (Class, definition, namedParameters) {
  return resolveMany(Class, definition, namedParameters);
};

exports.resolve = function (Class ,name, namedParameters) {
  return resolveDependency(Class, name, null, namedParameters, []);
};

function resolveMany(Class, definition, namedParameters, globalOptions, stack) {
  if (!definition || !definition.dependencies){
    return [];
  }
  if (!stack){
    stack = [];
  }
  if (!namedParameters){
    namedParameters = {};
  }

  var args = [].concat(definition.dependencies).map(function (name) {
    if (typeof name === 'object'){
      return Object.keys(name).map(function (key) {
        return resolveDependency(Class, key, name[key], namedParameters, stack);
      });
    }else{
      return [resolveDependency(Class, name, globalOptions, namedParameters, stack)];
    }
  });

  return Array.prototype.concat.apply([], args);
}

function resolveDependency(Class, name, localOptions, namedParameters, stack) {
  var factory;

  if (!namedParameters){
    namedParameters = {};
  }

  // Optional dependency
  var optional = exports.checkOptional(name);
  if (optional){
    name = optional;
    optional = true;
  }

  // Check named Parameters
  if (hasOwn(namedParameters, name)){
    return namedParameters[name];
  }

  // Special cases
  switch(name){
  case '$options':
    return localOptions;
  case '$namedParameters':
    return namedParameters;
  }

  // Check for recursive loop
  if (stack.indexOf(name) > -1){
    jpexError(['Recursive loop for dependency', name, 'encountered'].join(' '));
  }

  // Get the factory. If it returns null with no error, it must be optional
  factory = factoryService.getFactory(Class, name, optional);
  if (!factory){
    return factory;
  }

  // Check if already resolved
  if (factory.resolved){
    return factory.value;
  }

  // Constant values don't need any more evaluation
  if (factory.constant){
    var value = factory.value;
        // Process decorators
    value = factoryService.decorate(Class, value, factory.decorators);
        // Cache the result
    factoryService.cacheResult(Class, name, factory, value, namedParameters);

    return value;
  }

  // Work out arguments
  var args;

  if (factory.dependencies && factory.dependencies.length){
    try{
      args = resolveMany(Class, factory, namedParameters, localOptions, stack.concat(name));
    }catch(e){
      if (optional){
        return;
      }else{
        throw e;
      }
    }
  }

  // Run the factory function
  var result = factory.fn.apply(Class, args);

    // Process decorators
  result = factoryService.decorate(Class, result, factory.decorators);

    // Cache the result
  factoryService.cacheResult(Class, name, factory, result, namedParameters);

  return result;
}

exports.checkOptional = function (name) {
  if (name[0] === '_' && name[name.length-1] === '_'){
    return name.substring(1, name.length-1);
  }else{
    return false;
  }
};

};

// /src/isNode.js
__jpex_modules__[8] = function(require, module, exports){
  var _process;

try{
  _process = eval('process');
}catch(e){
  // No process variable
}

module.exports = typeof _process === 'object' && _process.toString() === '[object process]';

};

// /src/unsafeRequire.js
__jpex_modules__[9] = function(require, module, exports){
  module.exports = function (name) { // eslint-disable-line
  return eval('require.main.require(name)');
};

};

// /src/plugins/index.js
__jpex_modules__[10] = function(require, module, exports){
  var hasOwn = require(2);

exports.use = function (plugin, config) {
  var Jpex = this;

  if (!plugin || !plugin.install || typeof plugin.install !== 'function'){
    throw new Error('Plugin does not have an install method');
  }
  if (!plugin.name || typeof plugin.name !== 'string'){
    throw new Error('Plugin must have a name property');
  }

  if (this.$$using[plugin.name] && !plugin.reuse){
    if (!plugin.silent){
      console.warn('Plugin ' + plugin.name + ' skipped as it has already been used'); // eslint-disable-line
    }
    return;
  }else{
    this.$$using[plugin.name] = true;
  }

  var options = {
    Jpex : Jpex,
    on : function (name, fn) {
      addHook(Jpex, name, fn);
    },
    options : config
  };

  plugin.install(options);
};

exports.trigger = function (name, payload) {
  var hook = this.$$hooks[name];
  if (!hook){
    return;
  }

  hook.trigger(payload);
};

function addHook(Class, name, fn) {
  var hooks = Class.$$hooks;

  if (!hooks[name]){
    var id = 0;
    var Parent = Class;
    while (Parent.$$parent && Parent.$$parent.$$parent){
      Parent = Parent.$$parent;
    }
    Parent.$$hooks[name] = Object.create({
      push : function (fn) {
        this[id++] = fn;
      },
      trigger : function (payload) {
        payload = Object.assign({ Jpex : Class, eventName : name }, payload);
        Array.prototype.slice.call(this).forEach(function (fn) {
          if (fn){
            fn(payload);
          }
        });
      }
    }, {
      length : {
        get : function () {
          return id;
        }
      }
    });
  }
  if (!hasOwn(hooks, name)){
    hooks[name] = Object.create(Class.$$parent.$$hooks[name] || null);
  }
  hooks[name].push(fn);
}

};

// /src/class/privates.js
__jpex_modules__[7] = function(require, module, exports){
  var isNode = require(8);
var hasOwn = require(2);
var unsafeRequire = require(9);
var triggerHook = require(10).trigger;
var resolver = require(4);

function getFromNodeModules(name) {
  if (!isNode){
    return;
  }
  // In order to stop webpack and browserify from requiring every possible file, we have to wrap the require statement in an eval
  try{
    var result = unsafeRequire(name);
    this.register.constant(name, result);
    return this.$$factories[name];
  }catch(e){
    if (!(e && e.message && e.message.substr(0, 6) === 'Cannot')){
      throw e;
    }
  }
}
function namedParameters(keys, values, args) {
  if (!args || typeof args !== 'object'){
    args = {};
  }

  var i = 0;
  if (keys && values){
    keys.forEach(function (key) {
      if (typeof key === 'object'){
        Object.keys(key).forEach(function (key) {
          if (args[key] === undefined && values[i] !== undefined){
            args[key] = values[i];
          }
          i++;
        });
      }else{
        if (args[key] === undefined && values[i] !== undefined){
          args[key] = values[i];
        }
        i++;
      }
    });
  }

  return args;
}

function invokeParent(instance, values, args) {
  if (values && !Array.isArray(values)){
    values = Array.prototype.slice.call(values);
  }
  args = this.$$namedParameters(values, args);
  var Parent = this.$$parent;
  Parent.call(instance, args);
}

function resolve(name, namedParameters) {
  return Array.isArray(name) ?
    resolver.resolveDependencies(this, {dependencies : name}, namedParameters) :
    resolver.resolve(this, name, namedParameters);
}

function encase(dependencies, fn) {
  var self = this;
  if (typeof dependencies === 'function') {
    fn = dependencies;
    dependencies = resolver.extractParameters(fn);
  }
  return function () {
    var context = this;
    var args = Array.prototype.slice.call(arguments);
    var deps = self.$resolve(dependencies);
    return fn.apply(context, deps).apply(context, args);
  };
}

function clearCache(names) {
  names = names ? [].concat(names) : [];
  var key;
  for (key in this.$$factories){
    if (!names.length || names.indexOf(key) > -1){
      this.$$factories[key].resolved = false;
    }
  }
  for (key in this.$$resolved){
    if (!names.length || names.indexOf(key) > -1){
      delete this.$$resolved[key];
    }
  }
}

module.exports = function (Parent, Class, options) {
  Object.defineProperties(Class, {
      // These are all publically documented methods that can be called from the top level
    $trigger : {
      value : triggerHook
    },
    $resolve : {
      value : resolve
    },
    $encase: {
      value: encase,
    },
    $clearCache : {
      value : clearCache
    },

      // Called from within the Jpex constructor/resolver
    $$getFromNodeModules : {
      value : getFromNodeModules
    },
    $$namedParameters : {
      value : namedParameters.bind(null, options.dependencies)
    },
    $$invokeParent : {
      value : invokeParent
    },
    $$parent : {
      value : Parent
    },
      // Properties that contain stored factories/settings
    $$using : {
      value : Object.create(Parent.$$using || null)
    },
    $$factories : {
      value : Object.create(Parent.$$factories || null)
    },
    $$resolved : {
      value : Object.create(Parent.$$interfaces || null)
    },
    $$config : {
      value : Object.assign(Object.create(Parent.$$config || null), options.config)
    },
    $$hooks : {
      value : Object.create(Parent.$$hooks || null)
    }
  });

  // PRIVATES HOOK
  Class.$trigger('privateProperties', {
    Class : Class,
    options : options,
    apply : function (opt) {
      var properties = {};
      Object.keys(opt).forEach(function (key) {
        var prop = { configurable : true, enumerable : false };
        var def = opt[key];
        if (def && def.get && typeof def.get === 'function'){
          prop.get = def.get;
        }
        if (def && def.set && typeof def.set === 'function'){
          prop.set = def.set;
        }
        if (def && hasOwn(def, 'value')){
          def = def.value;
        }
        if (!prop.get && !prop.set){
          prop.value = def;
        }
        properties[key] = prop;
      });

      Object.defineProperties(Class, properties);
    }
  });
};

};

// /src/factories/wrapper.js
__jpex_modules__[13] = function(require, module, exports){
  var constants = require(3);

module.exports = function (factory) {
  var wrapper = {
    lifecycle : {
      application : function () {
        factory.lifecycle = constants.APPLICATION;
        return wrapper;
      },
      class : function () {
        factory.lifecycle = constants.CLASS;
        return wrapper;
      },
      instance : function () {
        factory.lifecycle = constants.INSTANCE;
        return wrapper;
      },
      none : function () {
        factory.lifecycle = constants.NONE;
        return wrapper;
      }
    },
    bindToInstance: function () {
      factory.fn.bindToInstance = true;
      return wrapper;
    },
  };

  // WRAPPER HOOKS

  return wrapper;
};

};

// /src/factories/constant.js
__jpex_modules__[12] = function(require, module, exports){
  var wrapper = require(13);

module.exports = function (name, obj) {
  var f = { value : obj, constant : true };
  this.$$factories[name] = f;
  return wrapper(f).lifecycle.application();
};

};

// /src/factories/factory.js
__jpex_modules__[14] = function(require, module, exports){
  var extractParameters = require(4).extractParameters;
var wrapper = require(13);

module.exports = function (lifecycle, name, dependencies, fn) {
  if (typeof dependencies === 'function'){
    fn = dependencies;
    dependencies = null;
  }
  if (typeof fn !== 'function'){
    throw new Error('Factory ' + name + ' - fn must be a [Function]');
  }

  if (dependencies){
    dependencies = [].concat(dependencies);
  }else{
    dependencies = extractParameters(fn);
  }
  if (!dependencies.length){
    dependencies = null;
  }

  var f = {
    fn : fn,
    dependencies : dependencies,
    lifecycle : lifecycle
  };
  this.$$factories[name] = f;
  return wrapper(f);
};

};

// /src/instantiator.js
__jpex_modules__[16] = function(require, module, exports){
  module.exports = function(context, args){
  return new (Function.prototype.bind.apply(context, args));
};

};

// /src/factories/jaas.js
__jpex_modules__[17] = function(require, module, exports){
  var checkOptional = require(4).checkOptional;

// Jpex As A Service
module.exports = function (name, dependencies, Fn) {
  dependencies = dependencies ? [].concat(dependencies) : [];
  dependencies.unshift('$namedParameters');

  function factory() {
    var args = Array.prototype.slice.call(arguments);

    var params = {};

    // Get factory dependencies
    var i = 1;
    dependencies.slice(1).forEach(function (key) {
      if (typeof key === 'object'){
        Object.keys(key).forEach(function (key2) {
          var val = args[i++];
          
          if (val !== undefined){
            key2 = checkOptional(key2) || key2;
            params[key2] = val;
          }
        });
      }else{
        var val = args[i++];
        if (val !== undefined){
          key = checkOptional(key) || key;
          params[key] = val;
        }
      }
    });

    // Get named dependencies
    if (args[0] && typeof args[0] === 'object'){
      Object.keys(args[0]).forEach(function (key) {
        var val = args[0][key];
        if (val !== undefined){
          params[key] = val;
        }
      });
    }

    return new Fn(params);
  }

  var service = this.register.factory(name, dependencies, factory);

  return service;
};

};

// /src/factories/service.js
__jpex_modules__[15] = function(require, module, exports){
  var extractParameters = require(4).extractParameters;
var instantiator = require(16);
var jaas = require(17);

module.exports = function (name, dependencies, fn) {
  if (typeof dependencies === 'function'){
    fn = dependencies;
    dependencies = null;
  }

  if (typeof fn !== 'function'){
    throw new Error('Service ' + name + ' - fn must be a [Function]');
  }

  if (fn.extend && fn.register && fn.register.factory){
    return jaas.call(this, name, dependencies, fn);
  }

  if (dependencies){
    dependencies = [].concat(dependencies);
  }else{
    dependencies = extractParameters(fn);
  }

  function factory() {
    var args = Array.prototype.slice.call(arguments);
    var context = {};

    if (factory.bindToInstance) {
      dependencies.forEach(function (key, i) {
        context[key] = args[i];
      });
      fn.apply(context, args);
      return context;
    }

    args.unshift(context);
    return instantiator(fn, args);
  }

  return this.register.factory(name, dependencies, factory);
};

};

// /src/factories/decorator.js
__jpex_modules__[18] = function(require, module, exports){
  var hasOwn = require(2);

module.exports = function (name, fn) {
  var factory = this.$$factories[name];
  if (!factory){
    throw new Error('Decorator could not be applied as factory ' + name + ' has not been registered');
  }
  // If the factory does not exist on this class, we don't want to mutate the original definition
  // so copy the factory onto the current class...
  if (!hasOwn(this.$$factories, name)){
    factory = Object.assign({}, this.$$factories[name]);
    this.$$factories[name] = factory;
  }
  // If the factory has already been resolved, the decorator will never be called
  if (factory.resolved){
    factory.resolved = false;
  }
  if (this.$$resolved[name]){
    delete this.$$resolved[name];
  }

  factory.decorators = (factory.decorators || []).concat(fn);
};

};

// /src/factories/index.js
__jpex_modules__[11] = function(require, module, exports){
  var constant = require(12);
var factory = require(14);
var service = require(15);
var decorator = require(18);

module.exports = function (Class, options) {
  var register = function () {
    return register.factory.apply(null, arguments);
  };
  register.constant = constant.bind(Class);
  register.factory = factory.bind(Class, options.defaultLifecycle);
  register.service = service.bind(Class);
  register.decorator = decorator.bind(Class);

  // FACTORY HOOKS
  Class.$trigger('factories', {
    Class : Class,
    options : options,
    register : function (name, fn) {
      register[name] = fn.bind(Class);
    }
  });

  Object.defineProperty(Class, 'register', {
    value : register
  });
};

};

// /src/class/resolve.js
__jpex_modules__[19] = function(require, module, exports){
  var resolver = require(4);

module.exports = function (Jpex) {
  Jpex.register.factory('$resolve', ['$namedParameters'], function ($namedParameters) {
    var TheClass = this;
    return function (name, namedParameters) {
      namedParameters = Object.assign({}, $namedParameters, namedParameters);

      return Array.isArray(name) ?
            resolver.resolveDependencies(TheClass, {dependencies : name}, namedParameters) :
            resolver.resolve(TheClass, name, namedParameters);
    };
  });
};

};

// /src/class/index.js
__jpex_modules__[1] = function(require, module, exports){
  var hasOwn = require(2);
var constants = require(3);
var resolver = require(4);
var privates = require(7);
var factories = require(11);
var plugins = require(10);

module.exports = function () {
  // Start with a basic function constructor
  var Base = function(){};
  Base.extend = extend;
  Base.use = plugins.use;

  // Extend the vanilla constructor to apply all the jpex-ness
  var Jpex = Base.extend();

  // Add the only default factory, $resolve
  require(19)(Jpex);

  return Jpex;
};

function extend(options) {
  var Parent = this;
  options = createOptions(Parent, options);

  var Class = createClass(Parent, options);

  privates(Parent, Class, options);
  factories(Class, options);

  // EXTEND HOOK
  if (Parent.$trigger){
    Parent.$trigger('extend', {
      Class : Class,
      options : options
    });
  }

  return Class;
}

function createOptions(Parent, options) {
  var defaultOptions = {
    constructor : (typeof options === 'function') ? options : null,
    invokeParent : !(typeof options === 'function' || options && hasOwn(options, 'constructor') && options.constructor),
    methods : null,
    properties : null,
    static : null,
    config : null,
    dependencies : null,
    bindToInstance : false,
    defaultLifecycle : constants.INSTANCE
  };

  var configOptions = Object.assign(Object.create(Parent.$$config || null), options && options.config);

  // Can't use Object.assign to merge config options in as we also want to copy prototype properties
  for (var key in configOptions){
    defaultOptions[key] = configOptions[key];
  }

  // Merge options with defaults
  options = Object.assign({}, defaultOptions, options);

  // Get dependencies
  // Either read them from the options, or extract them from the constructor
  if (!options.dependencies && typeof options.constructor === 'function'){
    options.dependencies = resolver.extractParameters(options.constructor);
  }else if(options.dependencies){
    options.dependencies = [].concat(options.dependencies);
  }
  if (options.dependencies && !options.dependencies.length){
    options.dependencies = null;
  }

  // Set properties
  if (options.properties){
    options.properties = [].concat(options.properties);
  }

  // MERGE OPTIONS HOOK
  if (Parent.$trigger){
    Parent.$trigger('options', {
      options : options,
      merge : function () {
        var args = Array.prototype.slice.call(arguments);
        args.unshift(options);
        Object.assign.apply(Object, args);
      }
    });
  }

  return options;
}

function createClass(Parent, options) {
  var Class = classBody(Parent, options);

  Class.prototype = classPrototype(Parent, Class, options);

  Object.assign(Class, Parent, options.static);

  return Class;
}

function classBody(Parent, options) {
  var Class;
  Class = function (namedParameters) {
    // Don't allow the class to be called with a different context
    if (!(this instanceof Class)){
      return new Class(namedParameters);
    }

    try{
      // Resolve dependencies
      var args = resolver.resolveDependencies(Class, {dependencies : options.dependencies}, namedParameters);

      // BEFORE INSTANTIATE HOOK
      // (check that the class is not a parent of the current instance before hooking)
      if (this.constructor === Class){
        Class.$trigger('beforeCreate', {
          Class : Class,
          options : options,
          instance : this,
          args : args
        });
      }

      // Invoke Parent
      if (options.invokeParent && options.invokeParent !== 'after'){
        Class.$$invokeParent(this, args, namedParameters);
      }

      // Bind dependencies
      if (options.bindToInstance){
        bindToInstance(this, Class, args, options.bindToInstance);
      }

      // Properties
      if (options.properties){
        var properties = createProperties(options.properties);
        Object.defineProperties(this, properties);
      }

      // Invoke constructor
      if (typeof options.constructor === 'function'){
        options.constructor.apply(this, args);
      }

      // Invoke Parent
      if (options.invokeParent === 'after'){
        Class.$$invokeParent(this, args, namedParameters);
      }

      // AFTER INSTANTIATE HOOK
      if (this.constructor === Class){
        Class.$trigger('created', {
          Class : Class,
          options : options,
          instance : this,
          args : args
        });
      }
    }catch(e){
      if (e && e.jpexInternalError){
        e.stack = (new Error(e.message)).stack;
      }

      // Use error handler factory if available
      var errorHandler = resolver.resolve(Class, '_$errorHandler_', namedParameters);
      if (errorHandler){
        errorHandler(e);
      }else{
        throw e;
      }
    }
  };

  return Class;
}

function classPrototype(Parent, Class, options) {
  var prototype = Object.create(Parent.prototype);

  // Add new prototype methods
  if (options.methods){
    Object.assign(prototype, options.methods);
  }

  // Set the constructor
  prototype.constructor = Class;

  return prototype;
}

function createProperties(options) {
  var properties = {};

  options.forEach(function (option) {
    if (typeof option === 'string'){
      properties[option] = {
        configurable : true,
        enumerable : true,
        writable : true,
        value : undefined
      };
    }else if (option != null){
      Object.keys(option).forEach(function (key) {
        var def = option[key];
        var property = {};

        if (def == null) {
          return;
        }

        switch (typeof def){
        case 'object':
          break;
        case 'function':
          def = { watch : def };
          break;
        default:
          def = { value : def };
          break;
        }

        var hasValue = hasOwn(def, 'value'),
          hasGet = hasOwn(def, 'get') && typeof def.get === 'function',
          hasSet = hasOwn(def, 'set') && typeof def.set === 'function',
          hasWatch = hasOwn(def, 'watch') && typeof def.watch === 'function',
          hasDefault = hasOwn(def, 'default') && typeof def.default === 'function';

        if (hasValue || hasDefault || hasGet || hasSet || hasWatch){
          var value = hasValue ? def.value : (hasDefault ? def.default() : undefined);

          property.get = function () {
            return hasGet ? def.get.call(this, value) : value;
          };
          if (!hasOwn(def, 'writable') || def.writable){
            property.set = function (v) {
              var newValue = hasSet ? def.set.call(this, v, value) : v;
              if (hasWatch && newValue !== value){
                def.watch.call(this, newValue, value);
              }
              value = newValue;
            };
          }
          property.configurable = hasOwn(def, 'configurable') ? def.configurable : true;
          property.enumerable = hasOwn(def, 'enumerable') ? def.enumerable : true;
        }else{
          property.configurable = true;
          property.enumerable = true;
          property.writable = true;
          property.value = def;
        }

        properties[key] = property;
      });
    }
  });

  return properties;
}

function bindToInstance(instance, Class, args, option) {
  var bindTo = instance;
  // Attach dependencies to a property on the instance
  if (typeof option === 'string'){
    option.split('.').forEach(function (key) {
      bindTo[key] = bindTo[key] || {};
      bindTo = bindTo[key];
    });
  }
  // Get the dependency names
  var bindParameters = Class.$$namedParameters(args);

  Object.assign(bindTo, bindParameters);
}

};

// /src/index.js
__jpex_modules__[0] = function(require, module, exports){
  module.exports = require(1)();

};

  var __jpex_require__ = function(target){
    if (__jpex_require__.cache[target]){
      return __jpex_require__.cache[target];
    }
    var module = { exports : {} };
    var fn = __jpex_modules__[target];
    if (!fn){
      throw new Error('Could not find module ' + target);
    }
    fn(__jpex_require__, module, module.exports);
    __jpex_require__.cache[target] = module.exports;

    return module.exports;
  };
  __jpex_require__.cache = [];

  if (typeof module !== 'undefined'){
    module.exports = __jpex_require__(0);
  }else if (typeof window !== 'undefined'){
    window['Jpex'] = __jpex_require__(0);
  }
}());
